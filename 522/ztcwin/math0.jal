
	specification

	Bool ::= True | False  

	Int == INTEGER

	| Nat, Nat1 : P Int

	| N, N1, Z : P Int


	=== [X] ===============================================
	|  _ /= _ : X <-> X;
	|  _ in _ : X <-> P X;
	|  _ notin _ : X <-> P X
	-------------------------------------------------------

	{} [X] == { x : X | false }

	=== [X] ===============================================
	|  _ subset _, _ subseteq _ : P X <-> P X
	-------------------------------------------------------


	=== [X] ===============================================
	|  _ setunion _, _ setint _, _ setminus _ : 
	|	(P X & P X) --> P X
	-------------------------------------------------------

	=== [X] ===============================================
	|  Union, Intersection : P (P X) --> P X
	-------------------------------------------------------

	=== [X, Y] ============================================
	|  first : (X & Y) --> X;
	|  second : (X & Y) --> Y
	-------------------------------------------------------

	=== [X, Y] ============================================
	|  _ -> _ : (X & Y) --> (X & Y); 
	|  _ mapsto _ : (X & Y) --> (X & Y)
	-------------------------------------------------------

	=== [X, Y] ============================================
	|  dom : (X <-> Y) --> P X;
	|  ran : (X <-> Y) --> P Y
	-------------------------------------------------------

	=== [X, Y, U] =========================================
	|  _ :> _ : ((X <-> Y) & (Y <-> U)) --> (X <-> U);
	|  _ <: _ : ((Y <-> U) & (X <-> Y)) --> (X <-> U);
	|  _ comp _ : ((X <-> Y) & (Y <-> U)) --> (X <-> U);
	|  _ backcomp _ : ((Y <-> U) & (X <-> Y)) --> (X <-> U)
	-------------------------------------------------------

	=== [X, Y] ============================================
	|  _ <| _ : (P X & (X <-> Y)) --> (X <-> Y);
	|  _ |> _ : ((X <-> Y) & P Y) --> (X <-> Y);
	|  _ <+ _ : (P X & (X <-> Y)) --> (X <-> Y);
	|  _ +> _ : ((X <-> Y) & P Y) --> (X <-> Y);
	|  _ dres _ : (P X & (X <-> Y)) --> (X <-> Y);
	|  _ rres _ : ((X <-> Y) & P Y) --> (X <-> Y);
	|  _ dsub _ : (P X & (X <-> Y)) --> (X <-> Y);
	|  _ rsub _ : ((X <-> Y) & P Y) --> (X <-> Y)
	-------------------------------------------------------

	=== [X, Y] ============================================
	|  _ inversion : (X <-> Y) --> (Y <-> X);
	|  _ ~ : (X <-> Y) --> (Y <-> X)
	-------------------------------------------------------

	=== [X, Y] ============================================
	|  _ (| _ |) : ((X <-> Y) & P X) --> P Y
	-------------------------------------------------------

	=== [X, Y] ============================================
	|  _ += _ : ((X <-> Y) & (X <-> Y)) --> (X <-> Y)
	-------------------------------------------------------

	=== [X] ===============================================
	|  _ ^+, _ ^* : (X <-> X) --> (X <-> X);
	|  _ tclosure, _ rtclosure : (X <-> X) --> (X <-> X)
	-------------------------------------------------------


	|  _ + _, _ - _, _ * _ : (Int & Int) --> Int;
	|  _ div _, _ mod _ : (Int & Int) --> Int;
	|  - : Int --> Int;
	|  _ < _, _ > _, _ <= _, _ >= _ : Int <-> Int

	|  succ : Nat --> Nat;
	|  _ .. _ : (Int & Int) --> P Int

	=== [X] ===============================================
	|  iter : Int --> (X <-> X) --> (X <-> X)
	-------------------------------------------------------

	=== [X] ===============================================
	|  # : F X --> Nat
	-------------------------------------------------------

	|  min : P1 Int +-> Int;
	|  max : P1 Int +-> Int

	=== [X] ===============================================
	|  _ ^ _ : (seq X & seq X) --> seq X;
	|  rev   : seq X --> seq X
	-------------------------------------------------------

	=== [X] ===============================================
	|  head, last  : seq1 X --> X;
	|  tail, front : seq1 X --> seq X
	-------------------------------------------------------

	=== [X] ===============================================
	|  _ extract _ : (P Nat1 & seq X) --> seq X;
	|  _ -| _      : (P Nat1 & seq X) --> seq X;
	|  _ filter _  : (seq X & P X) --> seq X;
	|  _ |- _      : (seq X & P X) --> seq X;
	|  squash      : (Nat1 ++> X) --> seq X
	-------------------------------------------------------

	=== [X] ===============================================
	|  _ prefix _, _ suffix _, _ subseq _ : seq X <-> seq X
	-------------------------------------------------------

	=== [X] ===============================================
	|  dcat : seq (seq X) <-> seq X;
	|  ^/ :   seq (seq X) <-> seq X
	-------------------------------------------------------

	=== [I, X] ============================================
	|  disjoint _    : P (I +-> P X);
	|  _ partition _ : (I +-> P X) <-> P X
	-------------------------------------------------------

	=== [X] ===============================================
	|  count        : bag X >->> (X --> Nat);
	|  _ bagcount _ : (bag X & X) --> Nat;
	|  _ bagscale _ : (Nat & bag X) --> bag X
	-------------------------------------------------------

	=== [X] ===============================================
	|  _ inbag _  : X <-> bag X;
	|  _ subbag _ : bag X <-> bag X
	-------------------------------------------------------

	=== [X] ===============================================
	|  _ bagunion _, _ bagdiff _ : (bag X & bag X) --> bag X;
	|  _ ++ _, _ -- _ : (bag X & bag X) --> bag X
	-------------------------------------------------------

	=== [X] ===============================================
	|  items : seq X --> bag X
	-------------------------------------------------------


	end specification


