\documentclass[11pt]{article}

\usepackage{bs-zed}

\begin{document}

\title{Vanity Plates II}
\author{Ben Straub}
\maketitle

\iftypechecker
Consider the situation from our earlier assignment on Oregon Vanity Plates. Again imagine that you
have been charged with implementing the GUI and input checking associated with step 1 of the
attached application form for an Oregon Vanity Plate.

This time, you decide to write a Z specification for your implementation as a first step. As before,
choose any input structure you want. Please do the specification in state-schema style. The output
should be a sequence of CHAR representing a valid plate to be printed. For invalid plates, you may
either output an error or simply not output anything until the plate is valid, depending on whether
your specification is interactive or not.

The two obvious styles of specification are to accept individual typed input characters in the style
of the text editor example from the course text, or to accept as input an already-edited sequence of
chars to validate.

Please discuss as desired on the course discussion list: this is not a competitive assignment.

I would guess that this project will take 2-8 hours, depending on how comfortable you are with Z at
this point. But that's pretty much a wild guess.

(see plateapp.pdf; due 2/24)
\fi

\section{English}
The instructions on the form can be interpreted as a set of high-level requirements.  Assuming that
the input system resolves issues of handwriting quality, it boils down to the following:

\begin{enumerate}
\item \label{e:len} There are at most six ``regular'' characters, which may include a space or
  full-hyphen.
\item \label{e:chr} If all six regular characters are used, an additional character may be
  inserted.  The only valid characters for this rule are the space and half-hyphen.
\item \label{e:pat} Plates of the forms \textit{\#\#\#-AAA} and \textit{AAA-\#\#\#} are prohibited,
  where \textit{A} is any letter and \textit{\#} is any number.
\end{enumerate}

\section{Z Types}

Before we can talk about valid plate strings, we need to talk about what kind of characters are
valid.  

\begin{zed}
  CHAR  ::=  space | hyphen | halfspace | halfhyphen |      \\
  \t3 letter \ldata 1..26 \rdata | digit \ldata 0..9 \rdata \\
  DIGIT == \ran digit                                       \\
  LETTER == \ran letter                                     \\
  PUNCTALPHA == \{ space, hyphen \}                         \\
  PUNCTDEMI == \{ space, halfhyphen \}                      \\
  PUNCT == PUNCTALPHA \cup PUNCTDEMI
\end{zed}
The $CHAR$ type represents all valid characters for a plate.  We divide them into subsets to
facilitate rule validation later; rule \#\ref{e:pat} requires that we split this type into
alphabetic and numeric characters.

$PUNCTALPHA$ and $PUNCTDEMI$ define the punctuation characters that are valid in various
conditions, and $PUNCT$ defines the entire set of punctuation characters.

\todo[inline]{
  Make a note that this spec doesn't including recentering of the string.  Or include it, probably
  in the form of a $blank$ character.
}

And here's the type we'll use for input; a sequence of elements of type $CHAR$.

\begin{zed}
  STR == \seq CHAR
\end{zed}


\section{Z Schemas}

In order to handle punctuation, we define functions to separate a $STR$ into $CHAR$s and
punctuation.

\begin{axdef}
  punct : STR \fun STR
  \where
  \forall str : STR; p : PUNCT; a : CHAR @ \\
  \t1 punct~\langle \rangle = \langle \rangle \land \\
  \t1 punct~(\langle p \rangle \cat str) = \langle p \rangle \cat punct~str \land \\
  \t1 punct~(\langle a \rangle \cat str) = punct~str
\end{axdef}

\begin{axdef}
  nopunct : STR \fun STR
  \where
  \forall str : STR; p : PUNCT; a : CHAR  @ \\
  \t1 nopunct~\langle \rangle = \langle \rangle \land \\
  \t1 nopunct~(\langle p \rangle \cat str) = nopunct~str \land \\
  \t1 nopunct~(\langle a \rangle \cat str) = \langle a \rangle \cat nopunct~str
\end{axdef}

I'm choosing to do this as a full-string validation-checker, rather than a per-character
valid-string-producer, so I'll need an output status.  If I were getting paid for this, I'd probably
give more helpful error messages; \textit{this} validator has only two possible status values.

\begin{zed}
  STATUS ::= ok | error
\end{zed}

Now we can define our validator's program state; the input is a string, and the validator status.

\begin{schema}{ValidatorState}
  str? : STR \also
  status! : STATUS
\end{schema}

Next we define the catch-all error state, which we'll fall through into if none of our valid cases
apply.

\begin{schema}{ValidatorError}
  ValidatorState
  \where
  status! = error
\end{schema}

Now for the Rule \#\ref{e:len} validation: total length is at most 7, with at most one punctuation
character.

\begin{schema}{LengthIsValid}
  ValidatorState
  \where
  \#(nopunct~str?) \leq 6 \\
  \#(punct~str?) \leq 1   \\
  status! = ok
\end{schema}

According to \#\ref{e:chr}, the kinds of punctuation that are allowed depend on the length of the
string: only one punctuation character is allowed, the half-hyphen can only be used when the rest
of the string is full.

\begin{schema}{FullStringPunctuationIsValid}
  ValidatorState
  \where
  \#(nopunct~str?) = 6 \\
  (punct~str?)(1) \in PUNCTDEMI
\end{schema}

\begin{schema}{SparseStringPunctuationIsValid}
  ValidatorState
  \where
  \#(nopunct~str?) < 6 \\
  (punct~str?)(1) \in PUNCTALPHA
\end{schema}

Our last rule to validate is \#\ref{e:pat}, which is fairly straightforward.
\todo[inline]{Is it?!?!}

\begin{schema}{PatternIsValid}
  ValidatorState
  \where
  1 = 1
\end{schema}

\section{The End}

All that's left is to define the system in total.

\begin{zed}
  Validator \defs \\
  \t1(LengthIsValid \land FullStringPunctuationIsValid \land \\
  \t2 SparseStringPunctuationIsValid \land PatternIsValid) \lor \\
  \t1 ValidatorError
\end{zed}

\end{document}
